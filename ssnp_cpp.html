<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGPU SSNP Model</title>
  <style>
    body {
      margin: 0;
      background-color: #202020;
      color: #eee;
      font-family: Arial, sans-serif;
    }
    h1 {
      text-align: center;
    }
    #controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    #anglesList {
      margin-top: 5px;
      max-height: 100px;
      overflow-y: auto;
      border: 1px solid #555;
      padding: 5px;
      width: 200px;
      background-color: #333;
    }
    #viewer {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding: 10px;
      background-color: #111;
    }
    .slice-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-right: 20px;
    }
    canvas {
      image-rendering: pixelated;
      border: 1px solid #555;
    }
    .colorbar {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-left: 5px;
    }
    .colorbar canvas {
      width: 10px;
      height: 100%;
    }
    .colorbar-label {
      font-size: 0.75rem;
      text-align: center;
      color: #ccc;
    }
    .angle-label {
      font-size: 0.8rem;
      margin-top: 3px;
      color: #ccc;
    }
    
    /* New styles for angle selector */
    #angleSelectorContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
    }
    #angleSelector {
      width: 300px;
      height: 300px;
      border-radius: 50%;
      background-color: #333;
      position: relative;
      cursor: crosshair;
      border: 2px solid #555;
    }
    #anglePreview {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border-radius: 3px;
      pointer-events: none;
      display: none;
    }
    #currentAngle {
      margin-top: 10px;
      font-size: 1.1rem;
      color: #fff;
    }
    #angleIndicator {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: red;
      transform: translate(-50%, -50%);
      display: none;
    }
  </style>

  <!-- 1) Include UTIF.js (make sure UTIF.js is available at this path or substitute a CDN) -->
  <script src="UTIF.js"></script>
  <!-- 2) d3 (already present) -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
</head>
<body>
  <h1>WebGPU SSNP Model</h1>
  <div id="controls">
    <!-- Accept both .bin and .tif/.tiff -->
    <input type="file" id="fileInput" accept=".bin,.tif,.tiff" />
    
    <!-- Angle selector section -->
    <div id="angleSelectorContainer">
      <div id="angleSelector">
        <div id="angleIndicator"></div>
        <div id="anglePreview"></div>
      </div>
      <div id="currentAngle">Selected angle: (0.00, 0.00)</div>
    </div>
    
    <div>
      <input type="text" id="resInput" placeholder="Resolution (e.g. 0.1,0.2,0.1)" />
      <input type="text" id="naInput" placeholder="NA (e.g. 0.65)" />
      <label>
        <input type="checkbox" id="intensityInput" checked /> Intensity
      </label>
    </div>
    <button id="runBtn" disabled>Run</button>
  </div>
  <div id="viewer"></div>

  <script>
    if (!navigator.gpu) {
      alert("Your browser does not support WebGPU. Please use a compatible browser such as the latest version of Google Chrome or Edge.");
      // Optionally disable UI interactions
      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("fileInput").disabled = true;
        document.getElementById("runBtn").disabled = true;
      });
    }
  </script>

  <script>
    // Emscripten/WASM Module boilerplate
    var Module = {
      noInitialRun: true,
      print: function (text) {
        console.log(text);
      },
    };

    let currentAngle = [0, 0];

    // Helper: write a 32-bit‚Äêinteger header + float32 volume into a single ArrayBuffer
    function buildBinBufferFromFloatVolume(slices, width, height) {
      // slices: Array of Float32Array, each of length width*height
      const D = slices.length;
      const H = height;
      const W = width;
      const headerBytes = 4 * 3; // three int32
      const floatBytesPerSlice = W * H * 4;
      const totalBytes = headerBytes + D * floatBytesPerSlice;
      const buffer = new ArrayBuffer(totalBytes);
      const dv = new DataView(buffer);
      // Write D, H, W as int32
      dv.setInt32(0, D, true);
      dv.setInt32(4, H, true);
      dv.setInt32(8, W, true);
      // Copy each slice's Float32Array
      let offset = headerBytes;
      for (let d = 0; d < D; d++) {
        const sliceArr = slices[d];
        // Assume sliceArr is a Float32Array
        const floatView = new Float32Array(buffer, offset, W * H);
        floatView.set(sliceArr);
        offset += floatBytesPerSlice;
      }
      return buffer;
    }

    function plotSlices(flatArray, D, H, W, minArray, maxArray) {
      const viewer = document.getElementById('viewer');
      viewer.innerHTML = '';

      let idx = 0;
      for (let d = 0; d < D; d++) {
        const localMin = minArray[d];
        const localMax = maxArray[d];
        const scale = localMax - localMin || 1;

        const container = document.createElement('div');
        container.className = 'slice-container';

        const horizontalContainer = document.createElement('div');
        horizontalContainer.style.display = 'flex';
        horizontalContainer.style.flexDirection = 'row';
        horizontalContainer.style.alignItems = 'center';

        const canvas = document.createElement('canvas');
        canvas.width = W;
        canvas.height = H;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(W, H);

        for (let i = 0; i < H; i++) {
          for (let j = 0; j < W; j++) {
            const value = flatArray[idx++];
            const norm = (value - localMin) / scale;
            const [r, g, b] = colormap(norm);
            const pixelIndex = (i * W + j) * 4;
            imgData.data[pixelIndex] = r;
            imgData.data[pixelIndex + 1] = g;
            imgData.data[pixelIndex + 2] = b;
            imgData.data[pixelIndex + 3] = 255;
          }
        }

        ctx.putImageData(imgData, 0, 0);
        horizontalContainer.appendChild(canvas);

        const colorbar = document.createElement('div');
        colorbar.className = 'colorbar';
        const colorCanvas = document.createElement('canvas');
        colorCanvas.width = 10;
        colorCanvas.height = H;
        const colorCtx = colorCanvas.getContext('2d');
        const colorImg = colorCtx.createImageData(1, H);

        for (let i = 0; i < H; i++) {
          const t = 1 - i / (H - 1);
          const [r, g, b] = colormap(t);
          const idx2 = i * 4;
          colorImg.data[idx2] = r;
          colorImg.data[idx2 + 1] = g;
          colorImg.data[idx2 + 2] = b;
          colorImg.data[idx2 + 3] = 255;
        }
        for (let x = 0; x < 10; x++) {
          colorCtx.putImageData(colorImg, x, 0);
        }

        colorbar.appendChild(colorCanvas);
        const maxLabel = document.createElement('div');
        maxLabel.className = 'colorbar-label';
        maxLabel.textContent = localMax.toExponential(3);
        const minLabel = document.createElement('div');
        minLabel.className = 'colorbar-label';
        minLabel.textContent = localMin.toExponential(3);
        colorbar.insertBefore(maxLabel, colorCanvas);
        colorbar.appendChild(minLabel);

        horizontalContainer.appendChild(colorbar);
        container.appendChild(horizontalContainer);

        const angleLabel = document.createElement('div');
        angleLabel.className = 'angle-label';
        angleLabel.textContent = `Angle: (${currentAngle[0].toFixed(2)}, ${currentAngle[1].toFixed(2)})`;
        container.appendChild(angleLabel);

        viewer.appendChild(container);
      }
    }

    function colormap(t) {
      t = Math.max(0, Math.min(1, t));
      const c = d3.color(d3.interpolateViridis(t));
      return [c.r, c.g, c.b];
    }

    Module.onRuntimeInitialized = () => {
      const fileInput = document.getElementById("fileInput");
      const runBtn = document.getElementById("runBtn");
      const angleSelector = document.getElementById("angleSelector");
      const anglePreview = document.getElementById("anglePreview");
      const angleIndicator = document.getElementById("angleIndicator");
      const currentAngleDisplay = document.getElementById("currentAngle");

      // Set up angle selector
      angleSelector.addEventListener("mousemove", (e) => {
        const rect = angleSelector.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        // Get mouse position relative to center
        const mouseX = e.clientX - rect.left - centerX;
        const mouseY = e.clientY - rect.top - centerY;
        
        // Calculate distance from center
        const distance = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
        const maxDistance = centerX;
        
        // Normalize to unit circle
        let normalizedX = mouseX / maxDistance;
        let normalizedY = mouseY / maxDistance;
        
        // If outside circle, project onto circle
        if (distance > maxDistance) {
          const angle = Math.atan2(mouseY, mouseX);
          normalizedX = Math.cos(angle);
          normalizedY = Math.sin(angle);
        }
        
        // Update preview
        anglePreview.style.display = "block";
        anglePreview.style.left = `${e.clientX - rect.left + 10}px`;
        anglePreview.style.top = `${e.clientY - rect.top + 10}px`;
        anglePreview.textContent = `(${normalizedX.toFixed(2)}, ${normalizedY.toFixed(2)})`;
      });
      
      angleSelector.addEventListener("mouseleave", () => {
        anglePreview.style.display = "none";
      });
      
      angleSelector.addEventListener("click", (e) => {
        const rect = angleSelector.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        // Get mouse position relative to center
        const mouseX = e.clientX - rect.left - centerX;
        const mouseY = e.clientY - rect.top - centerY;
        
        // Calculate distance from center
        const distance = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
        const maxDistance = centerX;
        
        // Normalize to unit circle
        let normalizedX = mouseX / maxDistance;
        let normalizedY = mouseY / maxDistance;
        
        // If outside circle, project onto circle
        if (distance > maxDistance) {
          const angle = Math.atan2(mouseY, mouseX);
          normalizedX = Math.cos(angle);
          normalizedY = Math.sin(angle);
        }
        
        // Update current angle
        currentAngle = [normalizedX, normalizedY];
        currentAngleDisplay.textContent = `Selected angle: (${normalizedX.toFixed(2)}, ${normalizedY.toFixed(2)})`;
        
        // Show indicator
        angleIndicator.style.display = "block";
        angleIndicator.style.left = `${rect.width / 2 + normalizedX * maxDistance}px`;
        angleIndicator.style.top = `${rect.height / 2 + normalizedY * maxDistance}px`;
        
        // Automatically run the forward function
        runForwardFunction();
      });

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const name = file.name.toLowerCase();
        const ext = name.substring(name.lastIndexOf(".") + 1);

        if (ext === "bin") {
          const r = new FileReader();
          r.onload = () => {
            const data = new Uint8Array(r.result);
            FS.writeFile("input.bin", data);
            runBtn.disabled = false;
          };
          r.readAsArrayBuffer(file);

        } else if (ext === "tif" || ext === "tiff") {
          const reader = new FileReader();
          reader.onload = () => {
            const arrayBuffer = reader.result;
            const ifds = UTIF.decode(arrayBuffer);
            if (ifds.length === 0) {
              alert("No image slices found in TIFF.");
              return;
            }

            const slices = [];
            let width = null, height = null;
            for (let i = 0; i < ifds.length; i++) {
              UTIF.decodeImage(arrayBuffer, ifds[i]);
              const raw = ifds[i].data;
              if (!raw) {
                alert(`Could not decode slice #${i}`);
                return;
              }
              if (i === 0) {
                width = ifds[i].width;
                height = ifds[i].height;
              } else {
                if (ifds[i].width !== width || ifds[i].height !== height) {
                  alert("All TIFF slices must have identical dimensions.");
                  return;
                }
              }

              let floatSlice;
              if (raw instanceof Float32Array) {
                floatSlice = raw;
              } else if (raw instanceof Uint8Array && raw.length === width * height * 4) {
                floatSlice = new Float32Array(raw.buffer, raw.byteOffset, raw.length / 4);
              } else {
                floatSlice = new Float32Array(raw.length);
                for (let k = 0; k < raw.length; k++) {
                  floatSlice[k] = raw[k];
                }
              }

              slices.push(floatSlice);
            }

            const binBuffer = buildBinBufferFromFloatVolume(slices, width, height);
            FS.writeFile("input.bin", new Uint8Array(binBuffer));
            runBtn.disabled = false;
          };
          reader.readAsArrayBuffer(file);

        } else {
          alert("Unsupported file type: please select a .bin or .tif/.tiff");
        }
      });

      function runForwardFunction() {
        const resVal = document.getElementById("resInput").value.trim() || "0.1,0.1,0.1";
        const naVal = document.getElementById("naInput").value.trim() || "0.65";
        const intensityVal = document.getElementById("intensityInput").checked ? "1" : "0";

        const angleString = `${currentAngle[0]},${currentAngle[1]}`;
        const combinedParams = `${angleString}|${resVal}|${naVal}|${intensityVal}`;

        const viewer = document.getElementById("viewer");
        viewer.innerHTML = "";

        console.log("Sending to C++:", combinedParams);

        Module.ccall(
          "callSSNP",
          null,
          ["string"],
          [combinedParams],
          { async: true }
        ).catch(err => console.error("Error:", err));
      }

      runBtn.addEventListener("click", runForwardFunction);
    };
  </script>
  <script async src="ssnp_cpp.js"></script>
</body>
</html>