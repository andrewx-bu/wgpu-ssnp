#include "binary_pupil.h"

// INPUT PARAMS
struct Params {
    float na;
};

static size_t buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry cgammaBufferLayout = {};
    cgammaBufferLayout.binding = 0;
    cgammaBufferLayout.visibility = wgpu::ShaderStage::Compute;
    cgammaBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry maskBufferLayout = {};
    maskBufferLayout.binding = 1;
    maskBufferLayout.visibility = wgpu::ShaderStage::Compute;
    maskBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry uniformBufferLayout = {};
    uniformBufferLayout.binding = 2;
    uniformBufferLayout.visibility = wgpu::ShaderStage::Compute;
    uniformBufferLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry entries[] = {cgammaBufferLayout, maskBufferLayout, uniformBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 3;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer cgammaBuffer, 
    wgpu::Buffer maskBuffer, 
    wgpu::Buffer uniformBuffer
) {
    wgpu::BindGroupEntry cgammaEntry = {};
    cgammaEntry.binding = 0;
    cgammaEntry.buffer = cgammaBuffer;
    cgammaEntry.offset = 0;
    cgammaEntry.size = sizeof(float) * buffer_len;

    wgpu::BindGroupEntry maskEntry = {};
    maskEntry.binding = 1;
    maskEntry.buffer = maskBuffer;
    maskEntry.offset = 0;
    maskEntry.size = sizeof(uint32_t) * buffer_len;

    wgpu::BindGroupEntry uniformEntry = {};
    uniformEntry.binding = 2;
    uniformEntry.buffer = uniformBuffer;
    uniformEntry.offset = 0;
    uniformEntry.size = sizeof(Params);

    wgpu::BindGroupEntry entries[] = {cgammaEntry, maskEntry, uniformEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 3;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void binary_pupil(
    WebGPUContext& context, 
    wgpu::Buffer& maskBuffer,
    std::vector<int> shape,
    float na,
    std::optional<std::vector<float>> res 
) {
    buffer_len = shape[0] * shape[1];
    Params params = {na};

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;

    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/binary_pupil/binary_pupil.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer cgammaBuffer = createBuffer(device, nullptr, sizeof(float) * buffer_len, wgpu::BufferUsage::Storage);
    c_gamma(context, cgammaBuffer, res.value(), shape);
    wgpu::Buffer uniformBuffer = createBuffer(device, &params, sizeof(Params), wgpu::BufferUsage::Uniform);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(device, bindGroupLayout, cgammaBuffer, maskBuffer, uniformBuffer);

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    cgammaBuffer.release();
    uniformBuffer.release();
}#ifndef BINARY_PUPIL_H
#define BINARY_PUPIL_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <optional>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"
#include "../c_gamma/c_gamma.h"

void binary_pupil(
    WebGPUContext& context,
    wgpu::Buffer& outputBuffer,
    std::vector<int> shape,
    float na,
    std::optional<std::vector<float>> res = std::vector<float>{0.1, 0.1, 0.1}
);

#endif @group(0) @binding(0) var<storage, read> cgamma : array<f32>;
@group(0) @binding(1) var<storage, read_write> mask : array<u32>;
@group(0) @binding(2) var<uniform> params : f32;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cgamma)) {
        return;
    }
    
    let threshold = sqrt(1.0 - params * params);
    mask[idx] = select(0u, 1u, cgamma[idx] > threshold);
}#include "c_gamma.h"

// INPUT PARAMS
struct Params {
    std::vector<float> res;
    std::vector<int> shape;
};

static size_t output_buffer_len;
static size_t res_buffer_len;
static size_t shape_buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry shapeBufferLayout = {};
    shapeBufferLayout.binding = 0;
    shapeBufferLayout.visibility = wgpu::ShaderStage::Compute;
    shapeBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry resBufferLayout = {};
    resBufferLayout.binding = 1;
    resBufferLayout.visibility = wgpu::ShaderStage::Compute;
    resBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry outputBufferLayout = {};
    outputBufferLayout.binding = 2;
    outputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outputBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry entries[] = {shapeBufferLayout, resBufferLayout, outputBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 3;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer shapeBuffer, 
    wgpu::Buffer resBuffer, 
    wgpu::Buffer outputBuffer
) {
    wgpu::BindGroupEntry shapeEntry = {};
    shapeEntry.binding = 0;
    shapeEntry.buffer = shapeBuffer;
    shapeEntry.offset = 0;
    shapeEntry.size = sizeof(int) * shape_buffer_len;

    wgpu::BindGroupEntry resEntry = {};
    resEntry.binding = 1;
    resEntry.buffer = resBuffer;
    resEntry.offset = 0;
    resEntry.size = sizeof(float) * res_buffer_len;

    wgpu::BindGroupEntry outputEntry = {};
    outputEntry.binding = 2;
    outputEntry.buffer = outputBuffer;
    outputEntry.offset = 0;
    outputEntry.size = sizeof(float) * output_buffer_len;

    wgpu::BindGroupEntry entries[] = {shapeEntry, resEntry, outputEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 3;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void c_gamma(WebGPUContext& context, wgpu::Buffer& outputBuffer, std::vector<float> res, std::vector<int> shape) {
    // Calculate the total number of elements in the output buffer
    output_buffer_len = shape[0] * shape[1];
    res_buffer_len = res.size();
    shape_buffer_len = shape.size();

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;
    
    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/c_gamma/c_gamma.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer resBuffer = createBuffer(device, res.data(), sizeof(float) * res_buffer_len, wgpu::BufferUsage::Storage);
    wgpu::Buffer shapeBuffer = createBuffer(device, shape.data(), sizeof(int) * shape_buffer_len, wgpu::BufferUsage::Storage);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(device, bindGroupLayout, shapeBuffer, resBuffer, outputBuffer);

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(output_buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    resBuffer.release();
    shapeBuffer.release();
}#ifndef C_GAMMA_H
#define C_GAMMA_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"

void c_gamma(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    std::vector<float> res, 
    std::vector<int> shape
);

#endif 
@group(0) @binding(0) var<storage, read> shape: array<i32>;
@group(0) @binding(1) var<storage, read> res: array<f32>;
@group(0) @binding(2) var<storage, read_write> output: array<f32>;

const eps: f32 = 1E-8;

fn modulus(x: f32, y: f32) -> f32 {
    return x - y * floor(x / y);
}

fn near_0(index: i32, size: i32) -> f32 {
    return modulus(f32(index) / f32(size) + 0.5, 1.0) - 0.5;
}

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index: i32 = i32(global_id.x); // Use only the x-dimension for indexing

    let size_x: i32 = shape[0];
    let size_y: i32 = shape[1];
    let total_size: i32 = size_x * size_y;

    if (index >= total_size) {
        return;
    }

    let resolution_x: f32 = res[1];
    let resolution_y: f32 = res[2];

    let index_x: i32 = index / size_y;
    let index_y: i32 = index % size_y;


    let c_alpha: f32 = near_0(index_y, size_y) / resolution_y;
    let c_beta: f32 = near_0(index_x, size_x) / resolution_x;

    let alpha_square: f32 = c_alpha * c_alpha;
    let beta_square: f32 = c_beta * c_beta;

    let gamma: f32 = sqrt(max(1.0 - (alpha_square + beta_square), eps));

    output[index] = gamma;
}
#include "dft.h"

static size_t buffer_size;

struct Params {
    int rows;
    int cols;
};

// CREATING BIND GROUP LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry inputBufferLayout = {};
    inputBufferLayout.binding = 0;
    inputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    inputBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry outputBufferLayout = {};
    outputBufferLayout.binding = 1;
    outputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outputBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;
    
    wgpu::BindGroupLayoutEntry uniformBufferLayout = {};
    uniformBufferLayout.binding = 2;
    uniformBufferLayout.visibility = wgpu::ShaderStage::Compute;
    uniformBufferLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry inverseFlagLayout = {};
    inverseFlagLayout.binding = 3;
    inverseFlagLayout.visibility = wgpu::ShaderStage::Compute;
    inverseFlagLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry entries[] = {inputBufferLayout, outputBufferLayout, uniformBufferLayout, inverseFlagLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 4;      
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

// CREATING BIND GROUP
static wgpu::BindGroup createBindGroup(wgpu::Device& device, wgpu::BindGroupLayout bindGroupLayout, wgpu::Buffer inputBuffer, wgpu::Buffer outputBuffer, wgpu::Buffer uniformBuffer, wgpu::Buffer inverseFlagBuffer) {
    wgpu::BindGroupEntry inputEntry = {};
    inputEntry.binding = 0;
    inputEntry.buffer = inputBuffer;
    inputEntry.offset = 0;
    inputEntry.size = sizeof(float) * 2 * buffer_size;

    wgpu::BindGroupEntry outputEntry = {};
    outputEntry.binding = 1;
    outputEntry.buffer = outputBuffer;
    outputEntry.offset = 0;
    outputEntry.size = sizeof(float) * 2 * buffer_size;

    wgpu::BindGroupEntry uniformEntry = {};
    uniformEntry.binding = 2;
    uniformEntry.buffer = uniformBuffer;
    uniformEntry.offset = 0;
    uniformEntry.size = sizeof(Params);

    wgpu::BindGroupEntry inverseFlagEntry = {};
    inverseFlagEntry.binding = 3;
    inverseFlagEntry.buffer = inverseFlagBuffer;
    inverseFlagEntry.offset = 0;
    inverseFlagEntry.size = sizeof(uint32_t);  
    
    wgpu::BindGroupEntry entries[] = {inputEntry, outputEntry, uniformEntry, inverseFlagEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 4;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void dft(
    WebGPUContext& context, 
    wgpu::Buffer& finalOutputBuffer,
    wgpu::Buffer& inputBuffer,
    size_t buffersize,
    int rows, 
    int cols, 
    uint32_t doInverse
) {
    buffer_size = buffersize;
    Params params = {rows, cols};

    // Retrieve device and queue.
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;
    WorkgroupLimits limits = getWorkgroupLimits(device);
    limits.maxWorkgroupSizeX = std::min(limits.maxWorkgroupSizeX, sqrt(limits.maxInvocationsPerWorkgroup));
    limits.maxWorkgroupSizeY = std::min(limits.maxWorkgroupSizeY, sqrt(limits.maxInvocationsPerWorkgroup));

    // Create the uniform buffer for dimensions.
    wgpu::Buffer uniformBuffer = createBuffer(device, &params, sizeof(Params), wgpu::BufferUsage::Uniform);

    uint32_t inverseFlag = doInverse ? 1 : 0;
    wgpu::Buffer inverseFlagBuffer = createBuffer(device, &inverseFlag, sizeof(uint32_t), wgpu::BufferUsage::Uniform);  

    // ROW DFT PASS -> save output in intermediate buffer before column pass
    wgpu::Buffer intermediateBuffer = createBuffer(device, nullptr, sizeof(float) * 2 * buffer_size, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));

    std::string shaderCodeRow = readShaderFile("src/ssnp/dft/dft_row.wgsl", limits.maxWorkgroupSizeX, limits.maxWorkgroupSizeY);
    wgpu::ShaderModule shaderModuleRow = createShaderModule(device, shaderCodeRow);

    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroupRow = createBindGroup(device, bindGroupLayout, inputBuffer, intermediateBuffer, uniformBuffer, inverseFlagBuffer);
    wgpu::ComputePipeline computePipelineRow = createComputePipeline(device, shaderModuleRow, bindGroupLayout);

    // Note: same workgroups for row pass & col pass
    uint32_t workgroupsX = std::ceil(double(cols)/limits.maxWorkgroupSizeX);
    uint32_t workgroupsY = std::ceil(double(rows)/limits.maxWorkgroupSizeY);

    wgpu::CommandBuffer commandBufferRow = createComputeCommandBuffer(device, computePipelineRow, bindGroupRow, workgroupsX, workgroupsY);
    queue.submit(1, &commandBufferRow);

    // Clean row pass resources before doing column pass
    commandBufferRow.release();
    computePipelineRow.release();
    bindGroupRow.release();
    shaderModuleRow.release();

    // COLUMN DFT PASS
    std::string shaderCodeCol = readShaderFile("src/ssnp/dft/dft_col.wgsl", limits.maxWorkgroupSizeX, limits.maxWorkgroupSizeY);
    wgpu::ShaderModule shaderModuleCol = createShaderModule(device, shaderCodeCol);

    wgpu::BindGroup bindGroupCol = createBindGroup(device, bindGroupLayout, intermediateBuffer, finalOutputBuffer, uniformBuffer, inverseFlagBuffer);
    wgpu::ComputePipeline computePipelineCol = createComputePipeline(device, shaderModuleCol, bindGroupLayout);

    wgpu::CommandBuffer commandBufferCol = createComputeCommandBuffer(device, computePipelineCol, bindGroupCol, workgroupsX, workgroupsY);
    queue.submit(1, &commandBufferCol);

    // Clean all resources
    commandBufferCol.release();
    computePipelineCol.release();
    bindGroupCol.release();
    bindGroupLayout.release();
    shaderModuleCol.release();
    uniformBuffer.release();
    intermediateBuffer.release();
    inverseFlagBuffer.release();
}
#ifndef DFT_H
#define DFT_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <complex>
#include <vector>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"

void dft(
    WebGPUContext& context,
    wgpu::Buffer& outputBuffer,
    wgpu::Buffer& inputBuffer,
    size_t buffersize,
    int rows,
    int cols,
    uint32_t doInverse
);

#endif 
@group(0) @binding(0) var<storage, read> input: array<vec2<f32>>;
@group(0) @binding(1) var<storage, read_write> output: array<vec2<f32>>;
@group(0) @binding(2) var<uniform> dims: vec2<i32>; // rows, cols
@group(0) @binding(3) var<uniform> doInverse: u32; // IDFT flag

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let col = i32(global_id.x); 
    let l = i32(global_id.y);   // freq index
    if (col >= dims.y || l >= dims.x) {
        return;
    }
    
    var sum = vec2<f32>(0.0, 0.0);
    let pi = radians(180.0);
    
    // Determine sign based on inverse flag
    let sign = select(-2.0, 2.0, doInverse == 1);

    // Compute DFT/IDFT
    for (var row = 0; row < dims.x; row = row + 1) {
        let phase = fract(f32(row * l) / f32(dims.x)); // shrink phase to preserve precision
        let angle = sign * pi * phase;
        let euler = vec2<f32>(cos(angle), sin(angle));
        let idx = row * dims.y + col;
        let val = input[idx];

        // Euler Rule
        sum = sum + vec2<f32>(
            val.x * euler.x - val.y * euler.y,
            val.x * euler.y + val.y * euler.x
        );
    }
    
    // For IDFT, normalize by N (dims.x in this case)
    if (doInverse == 1) {
        sum = sum / f32(dims.x);
    }
    
    let outIndex = l * dims.y + col;
    output[outIndex] = sum;
}@group(0) @binding(0) var<storage, read> input: array<vec2<f32>>;
@group(0) @binding(1) var<storage, read_write> output: array<vec2<f32>>;
@group(0) @binding(2) var<uniform> dims: vec2<i32>; // rows, cols
@group(0) @binding(3) var<uniform> doInverse: u32; // IDFT flag

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let col = i32(global_id.x); 
    let row = i32(global_id.y); 
    if (col >= dims.y || row >= dims.x) {
        return;
    }
    
    var sum = vec2<f32>(0.0, 0.0);
    let pi = radians(180.0);
    
    // Determine sign based on inverse flag
    let sign = select(-2.0, 2.0, doInverse == 1);
    
    // Compute DFT/IDFT
    for (var x = 0; x < dims.y; x = x + 1) {
        let phase = fract(f32(col * x) / f32(dims.y)); // shrink phase to preserve precision
        let angle = sign * pi * phase;
        let euler = vec2<f32>(cos(angle), sin(angle));
        let idx = row * dims.y + x;
        let val = input[idx];

        // Euler rule
        sum = sum + vec2<f32>(
            val.x * euler.x - val.y * euler.y,
            val.x * euler.y + val.y * euler.x
        );
    }
    
    // For IDFT, we need to divide by N (dims.y in this case)
    if (doInverse == 1) {
        sum = sum / f32(dims.y);
    }
    
    let outIndex = row * dims.y + col;
    output[outIndex] = sum;
}#include "diffract.h"

// INPUT PARAMS
struct Params {
    float dz;
};

static size_t buffer_len;
static size_t res_buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry ufBufferLayout = {};
    ufBufferLayout.binding = 0;
    ufBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ufBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry ubBufferLayout = {};
    ubBufferLayout.binding = 1;
    ubBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ubBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry resBufferLayout = {};
    resBufferLayout.binding = 2;
    resBufferLayout.visibility = wgpu::ShaderStage::Compute;
    resBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry cgammaBufferLayout = {};
    cgammaBufferLayout.binding = 3;
    cgammaBufferLayout.visibility = wgpu::ShaderStage::Compute;
    cgammaBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry newUFBufferLayout = {};
    newUFBufferLayout.binding = 4;
    newUFBufferLayout.visibility = wgpu::ShaderStage::Compute;
    newUFBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry newUBBufferLayout = {};
    newUBBufferLayout.binding = 5;
    newUBBufferLayout.visibility = wgpu::ShaderStage::Compute;
    newUBBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry uniformBufferLayout = {};
    uniformBufferLayout.binding = 6;
    uniformBufferLayout.visibility = wgpu::ShaderStage::Compute;
    uniformBufferLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry entries[] = {ufBufferLayout, ubBufferLayout, resBufferLayout, cgammaBufferLayout, newUFBufferLayout, newUBBufferLayout, uniformBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 7;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer ufBuffer, 
    wgpu::Buffer ubBuffer, 
    wgpu::Buffer resBuffer, 
    wgpu::Buffer cgammaBuffer, 
    wgpu::Buffer newUFBuffer, 
    wgpu::Buffer newUBBuffer, 
    wgpu::Buffer uniformBuffer
) {
    wgpu::BindGroupEntry ufEntry = {};
    ufEntry.binding = 0;
    ufEntry.buffer = ufBuffer;
    ufEntry.offset = 0;
    ufEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry ubEntry = {};
    ubEntry.binding = 1;
    ubEntry.buffer = ubBuffer;
    ubEntry.offset = 0;
    ubEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry resEntry = {};
    resEntry.binding = 2;
    resEntry.buffer = resBuffer;
    resEntry.offset = 0;
    resEntry.size = sizeof(float) * res_buffer_len;

    wgpu::BindGroupEntry cgammaEntry = {};
    cgammaEntry.binding = 3;
    cgammaEntry.buffer = cgammaBuffer;
    cgammaEntry.offset = 0;
    cgammaEntry.size = sizeof(float) * buffer_len;

    wgpu::BindGroupEntry newUFEntry = {};
    newUFEntry.binding = 4;
    newUFEntry.buffer = newUFBuffer;
    newUFEntry.offset = 0;
    newUFEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry newUBEntry = {};
    newUBEntry.binding = 5;
    newUBEntry.buffer = newUBBuffer;
    newUBEntry.offset = 0;
    newUBEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry uniformEntry = {};
    uniformEntry.binding = 6;
    uniformEntry.buffer = uniformBuffer;
    uniformEntry.offset = 0;
    uniformEntry.size = sizeof(Params);

    wgpu::BindGroupEntry entries[] = {ufEntry, ubEntry, resEntry, cgammaEntry, newUFEntry, newUBEntry, uniformEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 7;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void diffract(
    WebGPUContext& context, 
    wgpu::Buffer& newUFBuffer, 
    wgpu::Buffer& newUBBuffer, 
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    size_t bufferlen,
    std::vector<int> shape,
    std::optional<std::vector<float>> res, 
    std::optional<float> dz
) {
    buffer_len = bufferlen;
    res_buffer_len = res.value().size();
    Params params = {dz.value()};

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;
    
    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/diffract/diffract.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer cgammaBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len, WGPUBufferUsage(wgpu::BufferUsage::Storage));
    c_gamma(context, cgammaBuffer, res.value(), shape);
    wgpu::Buffer resBuffer = createBuffer(device, res.value().data(), sizeof(float) * res_buffer_len, wgpu::BufferUsage::Storage);
    wgpu::Buffer uniformBuffer = createBuffer(device, &params, sizeof(Params), wgpu::BufferUsage::Uniform);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(device, bindGroupLayout, ufBuffer, ubBuffer, resBuffer, cgammaBuffer, newUFBuffer, newUBBuffer, uniformBuffer);

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    cgammaBuffer.release();
    resBuffer.release();
    uniformBuffer.release();
}#ifndef DIFFRACT_H
#define DIFFRACT_H
#include <fstream>
#include <sstream>
#include <cassert>
#include <cmath>
#include <vector>
#include <complex>
#include <optional>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"
#include "../c_gamma/c_gamma.h"

void diffract(
    WebGPUContext& context, 
    wgpu::Buffer& newUFBuffer, 
    wgpu::Buffer& newUBBuffer, 
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    size_t bufferlen,
    std::vector<int> shape,
    std::optional<std::vector<float>> res = std::vector<float>{0.1, 0.1, 0.1}, 
    std::optional<float> dz = 1.0
);

#endif @group(0) @binding(0) var<storage, read> uf : array<vec2<f32>>;
@group(0) @binding(1) var<storage, read> ub : array<vec2<f32>>;
@group(0) @binding(2) var<storage, read> res : array<f32>;
@group(0) @binding(3) var<storage, read> cgamma : array<f32>;
@group(0) @binding(4) var<storage, read_write> newUF : array<vec2<f32>>;
@group(0) @binding(5) var<storage, read_write> newUB : array<vec2<f32>>;
@group(0) @binding(6) var<uniform> params: f32;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&uf)) {
        return;
    }

    let pi = radians(180.0);
    let gamma = cgamma[idx];
    let kz = 2.0 * pi * res[2] * gamma;

    // Clamp exponent to prevent underflow/overflow
    let exponent = clamp((gamma - 0.2) * 5.0, -60.0, 0.0);
    let eva = exp(exponent);

    // Trig stability: use Taylor approximation for small kz
    let kz_dz = kz * params;

    let cos_kz_dz = cos(kz_dz) * eva;

    let sin_kz_dz =
        select(sin(kz_dz), kz_dz - (kz_dz * kz_dz * kz_dz) / 6.0, abs(kz_dz) < 1e-2) * eva;

    let p_mat_0 = cos_kz_dz;
    let p_mat_1 = sin_kz_dz / max(kz, 1e-6); // avoid divide-by-zero
    let p_mat_2 = -sin_kz_dz * kz;
    let p_mat_3 = cos_kz_dz;

    // FMA-style pattern: helps minimize rounding error
    let uf_x = uf[idx].x;
    let uf_y = uf[idx].y;
    let ub_x = ub[idx].x;
    let ub_y = ub[idx].y;

    newUF[idx] = vec2<f32>(
        p_mat_0 * uf_x + p_mat_1 * ub_x,
        p_mat_0 * uf_y + p_mat_1 * ub_y
    );

    newUB[idx] = vec2<f32>(
        p_mat_2 * uf_x + p_mat_3 * ub_x,
        p_mat_2 * uf_y + p_mat_3 * ub_y
    );
}
#include "forward.h"

// SSNP FORWARD FUNCTION
vector<vector<vector<float>>> forward(
    WebGPUContext& context, 
    vector<vector<vector<float>>> n, 
    vector<float> res, 
    float na, 
    vector<vector<float>> angles, 
    float n0,
    int outputType
) {
    vector<int> shape = {int(n[0].size()), int(n[0][0].size())};

    // initialize the final result output
    vector<vector<vector<float>>> result; // angle_size x shape[0] x shape[1]

    for(vector<float> c_ba : angles) {
        // CONFIGURING INPUT FIELD
        // Generate Forward/Backward
        size_t buffer_len = shape[0] * shape[1];
        wgpu::Buffer tiltResultBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        tilt(context, tiltResultBuffer, c_ba, shape, res);
        wgpu::Buffer forwardBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        dft(context, forwardBuffer, tiltResultBuffer, buffer_len, shape[0], shape[1], 0); // dft
        vector<float> backward(shape[0]*shape[1]*2, 0.0);
        wgpu::Buffer backwardBuffer = createBuffer(context.device, backward.data(), sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        tiltResultBuffer.release();
        
        // Get U/UD
        wgpu::Buffer U = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        wgpu::Buffer UD = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        merge_prop(context, U, UD, forwardBuffer, backwardBuffer, buffer_len, shape, res);
        forwardBuffer.release();
        backwardBuffer.release();

        // Traverse slices
        for(vector<vector<float>> slice : n) {
            // Propogate the wave
            wgpu::Buffer U2 = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            wgpu::Buffer UD2 = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            diffract(context, U2, UD2, U, UD, buffer_len, shape, res, 1.0);
            U.release();
            UD.release();
            U = U2; // reassign U value for next iter

            // Field to spatial domain
            wgpu::Buffer u = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            dft(context, u, U2, buffer_len, shape[0], shape[1], 1); // idft

            // Scattering effects
            UD = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            wgpu::Buffer scatterBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            vector<float> flatSlice;
            for (const auto& inner : slice) {
                flatSlice.insert(flatSlice.end(), inner.begin(), inner.end());
            }
            vector<float> complexSlice;
            for (float value : flatSlice) {
                complexSlice.push_back(value); // real part
                complexSlice.push_back(0); // 0 for imag part
            }        
            wgpu::Buffer sliceBuffer = createBuffer(context.device, complexSlice.data(), sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            scatter_factor(context, scatterBuffer, sliceBuffer, buffer_len, res[0], 1, n0); // compute scatter factor output
            scatter_effects(context, UD, scatterBuffer, u, UD2, buffer_len, shape); // compute ud - fft(scatter*u)
            u.release();
            scatterBuffer.release();
            sliceBuffer.release();
            UD2.release();
        }

        // Propagate the wave back to the focal plane
        wgpu::Buffer U2 = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        wgpu::Buffer UD2 = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));  
        diffract(context, U2, UD2, U, UD, buffer_len, shape, res, -1*float(n.size())/2);
        U.release();
        UD.release();

        // Merge the forward and backward fields from u and ∂u
        forwardBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        wgpu::Buffer _ = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        split_prop(context, forwardBuffer, _, U2, UD2, buffer_len, shape, res);
        _.release();
        U2.release();
        UD2.release();
        wgpu::Buffer pupilBuffer = createBuffer(context.device, nullptr, sizeof(int) * buffer_len, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        binary_pupil(context, pupilBuffer, shape, na, res);
        wgpu::Buffer finalForwardBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        mult(context, finalForwardBuffer, forwardBuffer, pupilBuffer, buffer_len);
        forwardBuffer.release();
        pupilBuffer.release();

        wgpu::Buffer complexSlice = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
        dft(context, complexSlice, finalForwardBuffer, buffer_len, shape[0], shape[1], 1); // idft
        finalForwardBuffer.release();
        
        // Complex output
        if (outputType == 2) {
            vector<float> complexData = readBack(context.device, context.queue, buffer_len * 2, complexSlice);
            complexSlice.release();
            
            // reshape for final result - 2 x H x W (real, imag)
            vector<vector<float>> realSlice(shape[0], vector<float>(shape[1], 0.0f));
            vector<vector<float>> imagSlice(shape[0], vector<float>(shape[1], 0.0f));
            for (int i = 0; i < shape[0]; i++) {
                for (int j = 0; j < shape[1]; j++) {
                    int idx = i * shape[1] + j;
                    realSlice[i][j] = complexData[idx * 2];     // real part
                    imagSlice[i][j] = complexData[idx * 2 + 1]; // imag part
                }
            }
            result.push_back(realSlice);
            result.push_back(imagSlice);
        } 
        
        // Default output
        else { 
            wgpu::Buffer sliceBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
            intense(context, sliceBuffer, complexSlice, buffer_len, outputType == 1);
            vector<float> slice = readBack(context.device, context.queue, buffer_len, sliceBuffer);
            complexSlice.release();
            sliceBuffer.release();

            // reshape for final result
            vector<vector<float>> reshapedSlice(shape[0], vector<float>(shape[1], 0.0f));
            for (int i = 0; i < shape[0]; i++) {
                for (int j = 0; j < shape[1]; j++) {
                    reshapedSlice[i][j] = slice[i * shape[1] + j];
                }
            }
            result.push_back(reshapedSlice);
        }
    }

    return result;
}#ifndef FORWARD_H
#define FORWARD_H
#include "scatter_factor/scatter_factor.h"
#include "diffract/diffract.h"
#include "binary_pupil/binary_pupil.h"
#include "tilt/tilt.h"
#include "merge_prop/merge_prop.h"
#include "split_prop/split_prop.h" 
#include "dft/dft.h"
#include "mult/mult.h"
#include "scatter_effects/scatter_effects.h"
#include "intensity/intensity.h"
#include "webgpu_utils.h"
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

vector<vector<vector<float>>> forward(
    WebGPUContext& context, 
    vector<vector<vector<float>>> n, 
    vector<float> res, 
    float na, 
    vector<vector<float>> angles, 
    float n0,
    int outputType
);

#endif#include "intensity.h"

struct Params {
    int intensity;
};

static size_t buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry inputBufferLayout = {};
    inputBufferLayout.binding = 0;
    inputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    inputBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry outputBufferLayout = {};
    outputBufferLayout.binding = 1;
    outputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outputBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry uniformBufferLayout = {};
    uniformBufferLayout.binding = 2;
    uniformBufferLayout.visibility = wgpu::ShaderStage::Compute;
    uniformBufferLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry entries[] = {inputBufferLayout, outputBufferLayout, uniformBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 3;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer inputBuffer, 
    wgpu::Buffer outputBuffer, 
    wgpu::Buffer uniformBuffer
) {
    wgpu::BindGroupEntry inputEntry = {};
    inputEntry.binding = 0;
    inputEntry.buffer = inputBuffer;
    inputEntry.offset = 0;
    inputEntry.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry outputEntry = {};
    outputEntry.binding = 1;
    outputEntry.buffer = outputBuffer;
    outputEntry.offset = 0;
    outputEntry.size = sizeof(float) * buffer_len;

    wgpu::BindGroupEntry uniformEntry = {};
    uniformEntry.binding = 2;
    uniformEntry.buffer = uniformBuffer;
    uniformEntry.offset = 0;
    uniformEntry.size = sizeof(Params);

    wgpu::BindGroupEntry entries[] = {inputEntry, outputEntry, uniformEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 3;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void intense(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& inputBuffer, 
    size_t bufferlen,
    bool intensity
) {
    buffer_len = bufferlen;
    Params params = {int(intensity)};

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;

    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/intensity/intensity.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer uniformBuffer = createBuffer(device, &params, sizeof(Params), wgpu::BufferUsage::Uniform);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device, 
        bindGroupLayout, 
        inputBuffer, 
        outputBuffer, 
        uniformBuffer
    );

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    uniformBuffer.release();
}#ifndef INTENSITY_H
#define INTENSITY_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"

void intense(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& inputBuffer,
    size_t bufferlen,
    bool intensity
);

#endif 
@group(0) @binding(0) var<storage, read> input: array<vec2<f32>>;
@group(0) @binding(1) var<storage, read_write> output: array<f32>;
@group(0) @binding(2) var<uniform> intensity: u32;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let i = id.x;
    if (i >= arrayLength(&output)) {
        return;
    }

    output[i] = length(input[i]); // abs(complex)
    if (intensity==1) {
        output[i] = pow(output[i], 2.0);
    }
}
#define WEBGPU_CPP_IMPLEMENTATION
#include "forward.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

using namespace std;

bool read_input_tensor(const string& filename, vector<vector<vector<float>>>& tensor, int& D, int& H, int& W) {
    ifstream in(filename, ios::binary);
    if (!in) {
        cerr << "Failed to open input file: " << filename << endl;
        return false;
    }

    // Read dimensions (3 x int32)
    in.read(reinterpret_cast<char*>(&D), sizeof(int));
    in.read(reinterpret_cast<char*>(&H), sizeof(int));
    in.read(reinterpret_cast<char*>(&W), sizeof(int));

    size_t total = static_cast<size_t>(D) * H * W;
    vector<float> buffer(total);
    in.read(reinterpret_cast<char*>(buffer.data()), total * sizeof(float));
    in.close();

    // Convert to 3D tensor
    tensor.resize(D, vector<vector<float>>(H, vector<float>(W)));
    size_t idx = 0;
    for (int d = 0; d < D; ++d)
        for (int i = 0; i < H; ++i)
            for (int j = 0; j < W; ++j)
                tensor[d][i][j] = buffer[idx++];

    return true;
}

bool write_output_tensor(const string& filename, const vector<vector<vector<float>>>& tensor) {
    ofstream out(filename, ios::binary);
    if (!out) {
        cerr << "Failed to open output file: " << filename << endl;
        return false;
    }

    int D = tensor.size();
    int H = tensor[0].size();
    int W = tensor[0][0].size();

    out.write(reinterpret_cast<char*>(&D), sizeof(int));
    out.write(reinterpret_cast<char*>(&H), sizeof(int));
    out.write(reinterpret_cast<char*>(&W), sizeof(int));

    for (int d = 0; d < D; ++d)
        for (int i = 0; i < H; ++i)
            out.write(reinterpret_cast<const char*>(tensor[d][i].data()), W * sizeof(float));

    out.close();
    return true;
}

// Main for testing script
int main(int argc, char* argv[]) {
    if (argc < 3) {
        cerr << "Usage: " << argv[0] << " <input.bin> <output.bin>" << endl;
        return 1;
    }

    string input_filename = argv[1];
    string output_filename = argv[2];

    vector<vector<vector<float>>> input_tensor;
    int D, H, W;

    if (!read_input_tensor(input_filename, input_tensor, D, H, W)) return 1;

    WebGPUContext context;
    initWebGPU(context);

    vector<float> res = {0.1f, 0.1f, 0.1f};
    float na = 0.65f;
    int outputType = 1;
    float n0 = 1.33f;
    vector<vector<float>> angles(1, vector<float>(2, 0.0f)); // default [0, 0]

    auto result = forward(context, input_tensor, res, na, angles, n0, outputType);

    if (!write_output_tensor(output_filename, result)) return 1;

    return 0;
}

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#include <sstream>

EM_JS(void, plot_from_heap, (uintptr_t ptr, int len, int H, int W, float mn, float mx), {
  var view = new Float32Array(HEAPF32.buffer, ptr, len);
  plotSlices(view, H|0, W|0, Number(mn), Number(mx));
});

EM_JS(void, plot_complex_from_heap, (uintptr_t ptr, int len, int H, int W, float magMin, float magMax, float phaseMin, float phaseMax), {
  var view = new Float32Array(HEAPF32.buffer, ptr, len * 2);
  plotComplexSlices(view, H|0, W|0, Number(magMin), Number(magMax), Number(phaseMin), Number(phaseMax));
});

extern "C" {
    EMSCRIPTEN_KEEPALIVE
    void callSSNP(uintptr_t dataPtr, int D, int H, int W, const char* paramsStr) {
        try {
            // Parse params
            std::string fullInput(paramsStr);
            size_t firstPipe = fullInput.find('|');
            size_t secondPipe = fullInput.find('|', firstPipe + 1);
            size_t thirdPipe = fullInput.find('|', secondPipe + 1);
            size_t fourthPipe = fullInput.find('|', thirdPipe + 1);

            std::string anglesStr = fullInput.substr(0, firstPipe);
            std::string resStr = fullInput.substr(firstPipe + 1, secondPipe - firstPipe - 1);
            std::string naStr = fullInput.substr(secondPipe + 1, thirdPipe - secondPipe - 1);
            std::string outputTypeStr = fullInput.substr(thirdPipe + 1, fourthPipe - thirdPipe - 1);
            std::string n0Str = fullInput.substr(fourthPipe + 1);

            // Parse angles
            std::vector<std::vector<float>> angles;
            std::istringstream angleSS(anglesStr);
            std::string token;
            while (std::getline(angleSS, token, ';')) {
                std::istringstream pairStream(token);
                std::string xStr, yStr;
                std::getline(pairStream, xStr, ',');
                std::getline(pairStream, yStr, ',');
                angles.push_back({std::stof(xStr), std::stof(yStr)});
            }

            // Parse resolution
            std::vector<float> res;
            std::istringstream resSS(resStr);
            while (std::getline(resSS, token, ',')) {
                res.push_back(std::stof(token));
            }

            float na = std::stof(naStr);
            int outputType = std::stoi(outputTypeStr);
            float n0 = std::stof(n0Str);

            // Read data from heap & convert to 3D tensor
            float* heapData = reinterpret_cast<float*>(dataPtr);
            vector<vector<vector<float>>> tensor(D, vector<vector<float>>(H, vector<float>(W)));
            size_t idx = 0;
            for (int d = 0; d < D; ++d)
                for (int i = 0; i < H; ++i)
                    for (int j = 0; j < W; ++j)
                        tensor[d][i][j] = heapData[idx++];

            // Init WebGPU
            WebGPUContext context;
            initWebGPU(context);

            // Pass n0 to forward function
            auto result = forward(context, tensor, res, na, angles, n0, outputType);
            
            // Complex output
            if (outputType == 2) {
                auto realPart = result[0];
                auto imagPart = result[1];
                
                size_t N = (size_t)H * (size_t)W;
                float* complexOut = (float*)malloc(sizeof(float) * N * 2);
                
                // Calculate magnitude and phase
                float magMin = INFINITY, magMax = -INFINITY;
                float phaseMin = INFINITY, phaseMax = -INFINITY;
                
                for (int i = 0; i < H; ++i) {
                    for (int j = 0; j < W; ++j) {
                        float real = realPart[i][j];
                        float imag = imagPart[i][j];
                        float mag = sqrt(real*real + imag*imag);
                        float phase = atan2(imag, real);
                        
                        size_t idx = i * W + j;
                        complexOut[idx * 2] = real;
                        complexOut[idx * 2 + 1] = imag;
                        
                        if (mag < magMin) magMin = mag;
                        if (mag > magMax) magMax = mag;
                        if (phase < phaseMin) phaseMin = phase;
                        if (phase > phaseMax) phaseMax = phase;
                    }
                }
                
                plot_complex_from_heap((uintptr_t)complexOut, N, H, W, magMin, magMax, phaseMin, phaseMax);
                free(complexOut);
            } 
            
            // Amplitude/Intensity outputs
            else {
                auto output = result[0];
                
                size_t N = (size_t)H * (size_t)W;
                float* out = (float*)malloc(sizeof(float) * N);
                size_t k = 0;

                float localMin = output[0][0];
                float localMax = output[0][0];
                for (int i = 0; i < H; ++i) {
                    for (int j = 0; j < W; ++j) {
                        float v = output[i][j];
                        out[k++] = v;
                        if (v < localMin) localMin = v;
                        if (v > localMax) localMax = v;
                    }
                }

                plot_from_heap((uintptr_t)out, N, H, W, localMin, localMax);
                free(out);
            }

        } catch (const std::exception &e) {
            printf("C++ exception: %s\n", e.what());
        } catch (...) {
            printf("Unknown C++ exception\n");
        }
    }
}
#endif#include "merge_prop.h"

static size_t buffer_len;
static size_t res_buffer_len;

// CREATING BIND GROUP LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry ufBufferLayout = {};
    ufBufferLayout.binding = 0;
    ufBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ufBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry ubBufferLayout = {};
    ubBufferLayout.binding = 1;
    ubBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ubBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry resBufferLayout = {};
    resBufferLayout.binding = 2;
    resBufferLayout.visibility = wgpu::ShaderStage::Compute;
    resBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry cgammaBufferLayout = {};
    cgammaBufferLayout.binding = 3;
    cgammaBufferLayout.visibility = wgpu::ShaderStage::Compute;
    cgammaBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry ufNewBufferLayout = {};
    ufNewBufferLayout.binding = 4;
    ufNewBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ufNewBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry ubNewBufferLayout = {};
    ubNewBufferLayout.binding = 5;
    ubNewBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ubNewBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry entries[] = {
        ufBufferLayout,
        ubBufferLayout,
        resBufferLayout,
        cgammaBufferLayout,
        ufNewBufferLayout,
        ubNewBufferLayout
    };

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 6;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

// CREATING BIND GROUP
static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout,
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    wgpu::Buffer& resBuffer,
    wgpu::Buffer& cgammaBuffer,
    wgpu::Buffer& ufNewBuffer,
    wgpu::Buffer& ubNewBuffer
) {
    wgpu::BindGroupEntry ufEntry = {};
    ufEntry.binding = 0;
    ufEntry.buffer = ufBuffer;
    ufEntry.offset = 0;
    ufEntry.size = sizeof(float) * 2 * buffer_len;  // ×2 for complex numbers

    wgpu::BindGroupEntry ubEntry = {};
    ubEntry.binding = 1;
    ubEntry.buffer = ubBuffer;
    ubEntry.offset = 0;
    ubEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry resEntry = {};
    resEntry.binding = 2;
    resEntry.buffer = resBuffer;
    resEntry.offset = 0;
    resEntry.size = sizeof(float) * res_buffer_len;

    wgpu::BindGroupEntry cgammaEntry = {};
    cgammaEntry.binding = 3;
    cgammaEntry.buffer = cgammaBuffer;
    cgammaEntry.offset = 0;
    cgammaEntry.size = sizeof(float) * buffer_len;

    wgpu::BindGroupEntry ufNewEntry = {};
    ufNewEntry.binding = 4;
    ufNewEntry.buffer = ufNewBuffer;
    ufNewEntry.offset = 0;
    ufNewEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry ubNewEntry = {};
    ubNewEntry.binding = 5;
    ubNewEntry.buffer = ubNewBuffer;
    ubNewEntry.offset = 0;
    ubNewEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry entries[] = {
        ufEntry,
        ubEntry,
        resEntry,
        cgammaEntry,
        ufNewEntry,
        ubNewEntry
    };

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 6;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void merge_prop(
    WebGPUContext& context,
    wgpu::Buffer& ufNewBuffer,
    wgpu::Buffer& ubNewBuffer,
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    size_t bufferlen,
    std::vector<int> shape,
    std::optional<std::vector<float>> res
) {
    buffer_len = bufferlen;
    res_buffer_len = res.value().size();

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;
    
    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/merge_prop/merge_prop.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer cgammaBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len, wgpu::BufferUsage::Storage);
    c_gamma(context, cgammaBuffer, res.value(), shape);
    wgpu::Buffer resBuffer = createBuffer(device, res.value().data(), sizeof(float) * res_buffer_len, wgpu::BufferUsage::Storage);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device,
        bindGroupLayout,
        ufBuffer,
        ubBuffer,
        resBuffer,
        cgammaBuffer,
        ufNewBuffer,
        ubNewBuffer
    );

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    cgammaBuffer.release();
    resBuffer.release();
}#ifndef MERGE_PROP_H
#define MERGE_PROP_H
#include <fstream>
#include <sstream>
#include <cassert>
#include <cmath>
#include <vector>
#include <complex>
#include <optional>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"
#include "../c_gamma/c_gamma.h"

void merge_prop(
    WebGPUContext& context,
    wgpu::Buffer& newUFBuffer,
    wgpu::Buffer& newUBBuffer,
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    size_t bufferlen,
    std::vector<int> shape,
    std::optional<std::vector<float>> res = std::vector<float>{0.1, 0.1, 0.1}
);

#endif@group(0) @binding(0) var<storage, read> uf : array<vec2<f32>>;
@group(0) @binding(1) var<storage, read> ub : array<vec2<f32>>;
@group(0) @binding(2) var<storage, read> res : array<f32>;
@group(0) @binding(3) var<storage, read> cgamma : array<f32>;
@group(0) @binding(4) var<storage, read_write> uf_new : array<vec2<f32>>;
@group(0) @binding(5) var<storage, read_write> ub_new : array<vec2<f32>>;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&uf)) {
        return;
    }

    let pi = radians(180.0); 
    let kz = cgamma[idx] * (2.0 * pi * res[2]);

    // Complex addition: uf_new = uf + ub
    uf_new[idx] = uf[idx] + ub[idx];
    
    // Complex multiplication: ub_new = (uf - ub) * 1j * kz
    let uf_minus_ub = uf[idx] - ub[idx];
    let imaginary_kz = vec2<f32>(-uf_minus_ub.y * kz, uf_minus_ub.x * kz);
    ub_new[idx] = imaginary_kz;
}#include "mult.h"

static size_t buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry inputBuffer1Layout = {};
    inputBuffer1Layout.binding = 0;
    inputBuffer1Layout.visibility = wgpu::ShaderStage::Compute;
    inputBuffer1Layout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry inputBuffer2Layout = {};
    inputBuffer2Layout.binding = 1;
    inputBuffer2Layout.visibility = wgpu::ShaderStage::Compute;
    inputBuffer2Layout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry outputBufferLayout = {};
    outputBufferLayout.binding = 2;
    outputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outputBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry entries[] = {inputBuffer1Layout, inputBuffer2Layout, outputBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 3;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer inputBuffer1, 
    wgpu::Buffer inputBuffer2,
    wgpu::Buffer outputBuffer
) {
    wgpu::BindGroupEntry inputEntry1 = {};
    inputEntry1.binding = 0;
    inputEntry1.buffer = inputBuffer1;
    inputEntry1.offset = 0;
    inputEntry1.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry inputEntry2 = {};
    inputEntry2.binding = 1;
    inputEntry2.buffer = inputBuffer2;
    inputEntry2.offset = 0;
    inputEntry2.size = sizeof(float) * buffer_len;

    wgpu::BindGroupEntry outputEntry = {};
    outputEntry.binding = 2;
    outputEntry.buffer = outputBuffer;
    outputEntry.offset = 0;
    outputEntry.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry entries[] = {inputEntry1, inputEntry2, outputEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 3;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void mult(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& inputBuffer1, // forward
    wgpu::Buffer& inputBuffer2, // pupil
    size_t bufferlen
) {
    buffer_len = bufferlen;

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;

    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/mult/mult.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device, 
        bindGroupLayout, 
        inputBuffer1,
        inputBuffer2,
        outputBuffer
    );

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
}#ifndef MULT_H
#define MULT_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"

void mult(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& inputBuffer1, 
    wgpu::Buffer& inputBuffer2,
    size_t bufferlen
);

#endif 
@group(0) @binding(0) var<storage, read> forward: array<vec2<f32>>; 
@group(0) @binding(1) var<storage, read> pupil: array<u32>;
@group(0) @binding(2) var<storage, read_write> output_result: array<vec2<f32>>;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let i = id.x;
    if (i >= arrayLength(&output_result)) {
        return;
    }
    if (pupil[i] == 1) {
        output_result[i] = forward[i];
    }
    else {
        output_result[i] = vec2<f32>(0,0);
    }
}@group(0) @binding(0) var<storage, read> scatter: array<vec2<f32>>;
@group(0) @binding(1) var<storage, read> u: array<vec2<f32>>;
@group(0) @binding(2) var<storage, read_write> out: array<vec2<f32>>;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let i = id.x;
    if (i >= arrayLength(&out)) {
        return;
    }

    out[i] = vec2<f32>(
        scatter[i].x * u[i].x - scatter[i].y * u[i].y, // Real part
        scatter[i].x * u[i].y + scatter[i].y * u[i].x  // Imaginary part
    );
}
@group(0) @binding(0) var<storage, read> ud: array<vec2<f32>>;
@group(0) @binding(1) var<storage, read> fft: array<vec2<f32>>;
@group(0) @binding(2) var<storage, read_write> out: array<vec2<f32>>;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let i = id.x;
    if (i >= arrayLength(&out)) {
        return;
    }

    out[i] = ud[i] - fft[i];
}
#include "scatter_effects.h"

static size_t buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry inputBufferLayout1 = {};
    inputBufferLayout1.binding = 0;
    inputBufferLayout1.visibility = wgpu::ShaderStage::Compute;
    inputBufferLayout1.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry inputBufferLayout2 = {};
    inputBufferLayout2.binding = 1;
    inputBufferLayout2.visibility = wgpu::ShaderStage::Compute;
    inputBufferLayout2.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;
   
    wgpu::BindGroupLayoutEntry outputBufferLayout = {};
    outputBufferLayout.binding = 2;
    outputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outputBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry entries[] = {inputBufferLayout1, inputBufferLayout2, outputBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 3;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer inputBuffer1, 
    wgpu::Buffer inputBuffer2,
    wgpu::Buffer outputBuffer
) {
    wgpu::BindGroupEntry inputEntry1 = {};
    inputEntry1.binding = 0;
    inputEntry1.buffer = inputBuffer1;
    inputEntry1.offset = 0;
    inputEntry1.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry inputEntry2 = {};
    inputEntry2.binding = 1;
    inputEntry2.buffer = inputBuffer2;
    inputEntry2.offset = 0;
    inputEntry2.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry outputEntry = {};
    outputEntry.binding = 2;
    outputEntry.buffer = outputBuffer;
    outputEntry.offset = 0;
    outputEntry.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry entries[] = {inputEntry1, inputEntry2, outputEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 3;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void scatter_effects(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& scatterBuffer, 
    wgpu::Buffer& uBuffer, 
    wgpu::Buffer& udBuffer,
    size_t bufferlen,
    std::vector<int> shape
) {
    buffer_len = bufferlen;

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;

    // shader file for complex multiplication
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/scatter_effects/complex_mult.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // bind group/layout for complex multiplication
    wgpu::Buffer fftInputBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device, 
        bindGroupLayout, 
        scatterBuffer,
        uBuffer, 
        fftInputBuffer
    );

    // perform scatter factor * u
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // release resources so far
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();

    // perform fft(scatter*u)
    wgpu::Buffer fftBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len * 2, WGPUBufferUsage(wgpu::BufferUsage::Storage | wgpu::BufferUsage::CopySrc));
    dft(context, fftBuffer, fftInputBuffer, buffer_len, shape[0], shape[1], 0);
    fftInputBuffer.release();


    // shader file for subtraction
    shaderCode = readShaderFile("src/ssnp/scatter_effects/complex_sub.wgsl", limits.maxWorkgroupSizeX);
    shaderModule = createShaderModule(device, shaderCode);

    // bind group/layout for subtraction
    bindGroupLayout = createBindGroupLayout(device);
    bindGroup = createBindGroup(
        device, 
        bindGroupLayout, 
        udBuffer,
        fftBuffer, 
        outputBuffer
    );

    // perform ud - fft(scatter*u)
    computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);
    commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // Cleanup Resources
    fftBuffer.release();
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
}#ifndef SCATTER_EFFECTS_H
#define SCATTER_EFFECTS_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"
#include "../dft/dft.h"

void scatter_effects(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& scatterBuffer, 
    wgpu::Buffer& uBuffer, 
    wgpu::Buffer& udBuffer,
    size_t bufferlen,
    std::vector<int> shape
);

#endif 
#include "scatter_factor.h"

// INPUT PARAMS
struct Params {
    float res_z;
    float dz;
    float n0;
};

static size_t buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry inputBufferLayout = {};
    inputBufferLayout.binding = 0;
    inputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    inputBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry outputBufferLayout = {};
    outputBufferLayout.binding = 1;
    outputBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outputBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry uniformBufferLayout = {};
    uniformBufferLayout.binding = 2;
    uniformBufferLayout.visibility = wgpu::ShaderStage::Compute;
    uniformBufferLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry entries[] = {inputBufferLayout, outputBufferLayout, uniformBufferLayout};

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 3;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout, 
    wgpu::Buffer inputBuffer, 
    wgpu::Buffer outputBuffer, 
    wgpu::Buffer uniformBuffer
) {
    wgpu::BindGroupEntry inputEntry = {};
    inputEntry.binding = 0;
    inputEntry.buffer = inputBuffer;
    inputEntry.offset = 0;
    inputEntry.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry outputEntry = {};
    outputEntry.binding = 1;
    outputEntry.buffer = outputBuffer;
    outputEntry.offset = 0;
    outputEntry.size = sizeof(float) * buffer_len * 2;

    wgpu::BindGroupEntry uniformEntry = {};
    uniformEntry.binding = 2;
    uniformEntry.buffer = uniformBuffer;
    uniformEntry.offset = 0;
    uniformEntry.size = sizeof(Params);

    wgpu::BindGroupEntry entries[] = {inputEntry, outputEntry, uniformEntry};

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 3;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void scatter_factor(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& inputBuffer, 
    size_t bufferlen,
    std::optional<float> res_z, 
    std::optional<float> dz, 
    std::optional<float> n0
) {
    buffer_len = bufferlen;
    Params params = {res_z.value(), dz.value(), n0.value()};

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;

    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/scatter_factor/scatter_factor.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer uniformBuffer = createBuffer(device, &params, sizeof(Params), wgpu::BufferUsage::Uniform);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device, 
        bindGroupLayout, 
        inputBuffer, 
        outputBuffer, 
        uniformBuffer
    );

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    uniformBuffer.release();
}#ifndef SCATTER_FACTOR_H
#define SCATTER_FACTOR_H
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <optional>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"

void scatter_factor(
    WebGPUContext& context, 
    wgpu::Buffer& outputBuffer, 
    wgpu::Buffer& inputBuffer,
    size_t bufferlen,
    std::optional<float> res_z = 0.1, 
    std::optional<float> dz = 1, 
    std::optional<float> n0 = 1.33
);

#endif 
@group(0) @binding(0) var<storage, read> input_n: array<vec2<f32>>;
@group(0) @binding(1) var<storage, read_write> output_result: array<vec2<f32>>;
@group(0) @binding(2) var<uniform> params: vec3<f32>; // res_z, dz, n0

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let i = id.x;
    if (i >= arrayLength(&input_n)) {
        return;
    }

    let pi = radians(180.0);
    let a = input_n[i].x; // real
    let b = input_n[i].y; // imag

    let real_part = a * (2.0 * params.z + a) - b * b;
    let imag_part = b * (2.0 * params.z + 2.0 * a);

    let const_factor = pow(2.0 * pi * params.x / params.z, 2.0) * params.y;

    output_result[i] = const_factor * vec2<f32>(real_part, imag_part);
}
#include "split_prop.h"

static size_t buffer_len;
static size_t res_buffer_len;

// CREATING BIND GROUP LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry ufBufferLayout = {};
    ufBufferLayout.binding = 0;
    ufBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ufBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry ubBufferLayout = {};
    ubBufferLayout.binding = 1;
    ubBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ubBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry resBufferLayout = {};
    resBufferLayout.binding = 2;
    resBufferLayout.visibility = wgpu::ShaderStage::Compute;
    resBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry cgammaBufferLayout = {};
    cgammaBufferLayout.binding = 3;
    cgammaBufferLayout.visibility = wgpu::ShaderStage::Compute;
    cgammaBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry ufNewBufferLayout = {};
    ufNewBufferLayout.binding = 4;
    ufNewBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ufNewBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry ubNewBufferLayout = {};
    ubNewBufferLayout.binding = 5;
    ubNewBufferLayout.visibility = wgpu::ShaderStage::Compute;
    ubNewBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry entries[] = {
        ufBufferLayout,
        ubBufferLayout,
        resBufferLayout,
        cgammaBufferLayout,
        ufNewBufferLayout,
        ubNewBufferLayout
    };

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 6;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

// CREATING BIND GROUP
static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout,
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    wgpu::Buffer& resBuffer,
    wgpu::Buffer& cgammaBuffer,
    wgpu::Buffer& ufNewBuffer,
    wgpu::Buffer& ubNewBuffer
) {
    wgpu::BindGroupEntry ufEntry = {};
    ufEntry.binding = 0;
    ufEntry.buffer = ufBuffer;
    ufEntry.offset = 0;
    ufEntry.size = sizeof(float) * 2 * buffer_len;  // ×2 for complex numbers

    wgpu::BindGroupEntry ubEntry = {};
    ubEntry.binding = 1;
    ubEntry.buffer = ubBuffer;
    ubEntry.offset = 0;
    ubEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry resEntry = {};
    resEntry.binding = 2;
    resEntry.buffer = resBuffer;
    resEntry.offset = 0;
    resEntry.size = sizeof(float) * res_buffer_len; 

    wgpu::BindGroupEntry cgammaEntry = {};
    cgammaEntry.binding = 3;
    cgammaEntry.buffer = cgammaBuffer;
    cgammaEntry.offset = 0;
    cgammaEntry.size = sizeof(float) * buffer_len;

    wgpu::BindGroupEntry ufNewEntry = {};
    ufNewEntry.binding = 4;
    ufNewEntry.buffer = ufNewBuffer;
    ufNewEntry.offset = 0;
    ufNewEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry ubNewEntry = {};
    ubNewEntry.binding = 5;
    ubNewEntry.buffer = ubNewBuffer;
    ubNewEntry.offset = 0;
    ubNewEntry.size = sizeof(float) * 2 * buffer_len;

    wgpu::BindGroupEntry entries[] = {
        ufEntry,
        ubEntry,
        resEntry,
        cgammaEntry,
        ufNewEntry,
        ubNewEntry
    };

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 6;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void split_prop(
    WebGPUContext& context,
    wgpu::Buffer& ufNewBuffer,
    wgpu::Buffer& ubNewBuffer,
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    size_t bufferlen,
    std::vector<int> shape,
    std::optional<std::vector<float>> res
) {
    buffer_len = bufferlen;
    res_buffer_len = res.value().size();

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;
    
    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/split_prop/split_prop.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);

    // CREATING BUFFERS
    wgpu::Buffer cgammaBuffer = createBuffer(context.device, nullptr, sizeof(float) * buffer_len, wgpu::BufferUsage::Storage);
    c_gamma(context, cgammaBuffer, res.value(), shape);
    wgpu::Buffer resBuffer = createBuffer(device, res.value().data(), sizeof(float)*res_buffer_len, wgpu::BufferUsage::Storage);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device,
        bindGroupLayout,
        ufBuffer,
        ubBuffer,
        resBuffer,
        cgammaBuffer,
        ufNewBuffer,
        ubNewBuffer
    );

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);

    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    cgammaBuffer.release();
    resBuffer.release();
}#ifndef SPLIT_PROP_H
#define SPLIT_PROP_H
#include <fstream>
#include <sstream>
#include <cassert>
#include <cmath>
#include <vector>
#include <complex>
#include <optional>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"
#include "../c_gamma/c_gamma.h"

void split_prop(
    WebGPUContext& context,
    wgpu::Buffer& newUFBuffer,
    wgpu::Buffer& newUBBuffer,
    wgpu::Buffer& ufBuffer,
    wgpu::Buffer& ubBuffer,
    size_t bufferlen, 
    std::vector<int> shape,
    std::optional<std::vector<float>> res = std::vector<float>{0.1, 0.1, 0.1}
);

#endif@group(0) @binding(0) var<storage, read> uf : array<vec2<f32>>;
@group(0) @binding(1) var<storage, read> ub : array<vec2<f32>>;
@group(0) @binding(2) var<storage, read> res : array<f32>;
@group(0) @binding(3) var<storage, read> cgamma : array<f32>;
@group(0) @binding(4) var<storage, read_write> uf_new : array<vec2<f32>>;
@group(0) @binding(5) var<storage, read_write> ub_new : array<vec2<f32>>;

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&uf)) {
        return;
    }

    let pi = radians(180.0); 
    let kz = cgamma[idx] * (2.0 * pi * res[2]);
    
    // Complex division: 1j*ub/kz
    let result = vec2<f32>(-ub[idx].y / kz, ub[idx].x / kz);
    
    // ub_new = (uf + 1j*ub/kz)/2
    ub_new[idx] = (uf[idx] + result) / 2.0;
    
    // uf_new = uf - ub_new
    uf_new[idx] = uf[idx] - ub_new[idx];
}#include "tilt.h"

// INPUT PARAMS
struct Params {
    uint32_t trunc_flag;
};

static size_t out_buffer_len;

// CREATING BIND GROUP AND LAYOUT
static wgpu::BindGroupLayout createBindGroupLayout(wgpu::Device& device) {
    wgpu::BindGroupLayoutEntry cbaBufferLayout = {};
    cbaBufferLayout.binding = 0;
    cbaBufferLayout.visibility = wgpu::ShaderStage::Compute;
    cbaBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry shapeBufferLayout = {};
    shapeBufferLayout.binding = 1;
    shapeBufferLayout.visibility = wgpu::ShaderStage::Compute;
    shapeBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry resBufferLayout = {};
    resBufferLayout.binding = 2;
    resBufferLayout.visibility = wgpu::ShaderStage::Compute;
    resBufferLayout.buffer.type = wgpu::BufferBindingType::ReadOnlyStorage;

    wgpu::BindGroupLayoutEntry outBufferLayout = {};
    outBufferLayout.binding = 3;
    outBufferLayout.visibility = wgpu::ShaderStage::Compute;
    outBufferLayout.buffer.type = wgpu::BufferBindingType::Storage;

    wgpu::BindGroupLayoutEntry uniformTruncLayout = {};
    uniformTruncLayout.binding = 4;
    uniformTruncLayout.visibility = wgpu::ShaderStage::Compute;
    uniformTruncLayout.buffer.type = wgpu::BufferBindingType::Uniform;

    wgpu::BindGroupLayoutEntry entries[] = {
        cbaBufferLayout,
        shapeBufferLayout,
        resBufferLayout,
        outBufferLayout,
        uniformTruncLayout
    };

    wgpu::BindGroupLayoutDescriptor layoutDesc = {};
    layoutDesc.entryCount = 5;
    layoutDesc.entries = entries;

    return device.createBindGroupLayout(layoutDesc);
}

static wgpu::BindGroup createBindGroup(
    wgpu::Device& device, 
    wgpu::BindGroupLayout bindGroupLayout,
    wgpu::Buffer anglesBuffer,
    wgpu::Buffer shapeBuffer,
    wgpu::Buffer resBuffer,
    wgpu::Buffer outBuffer, 
    wgpu::Buffer uniformTruncBuffer
) {
    wgpu::BindGroupEntry cbaEntry = {};
    cbaEntry.binding = 0;
    cbaEntry.buffer = anglesBuffer;
    cbaEntry.offset = 0;
    cbaEntry.size = sizeof(float) * 2;

    wgpu::BindGroupEntry shapeEntry = {};
    shapeEntry.binding = 1;
    shapeEntry.buffer = shapeBuffer;
    shapeEntry.offset = 0;
    shapeEntry.size = sizeof(int) * 2; // Always 2 elements for shape

    wgpu::BindGroupEntry resEntry = {};
    resEntry.binding = 2;
    resEntry.buffer = resBuffer;
    resEntry.offset = 0;
    resEntry.size = sizeof(float) * 3; // Always 3 elements for res

    wgpu::BindGroupEntry outEntry = {};
    outEntry.binding = 3;
    outEntry.buffer = outBuffer;
    outEntry.offset = 0;
    outEntry.size = sizeof(float) * 2 * out_buffer_len;

    wgpu::BindGroupEntry uniformTruncEntry = {};
    uniformTruncEntry.binding = 4;
    uniformTruncEntry.buffer = uniformTruncBuffer;
    uniformTruncEntry.offset = 0;
    uniformTruncEntry.size = sizeof(uint32_t);

    wgpu::BindGroupEntry entries[] = {
        cbaEntry,
        shapeEntry,
        resEntry,
        outEntry,
        uniformTruncEntry
    };

    wgpu::BindGroupDescriptor bindGroupDesc = {};
    bindGroupDesc.layout = bindGroupLayout;
    bindGroupDesc.entryCount = 5;
    bindGroupDesc.entries = entries;

    return device.createBindGroup(bindGroupDesc);
}

void tilt(
    WebGPUContext& context,
    wgpu::Buffer& outBuffer,
    std::vector<float> c_ba,
    std::vector<int> shape,
    std::optional<std::vector<float>> res,
    std::optional<bool> trunc
) {
    // Validate inputs
    assert(shape.size() == 2 && "Shape must be 2D (height, width)");
    assert(res.value().size() == 3 && "Resolution must have 3 components");
    assert(c_ba.size() == 2 && "This tilt function only support's one angle's c_ba tuple at a time");

    out_buffer_len =  shape[0] * shape[1];  
    
    Params params = {
        trunc.value() ? 1u : 0u
    };

    // INITIALIZING WEBGPU
    wgpu::Device device = context.device;
    wgpu::Queue queue = context.queue;

    // LOADING AND COMPILING SHADER CODE
    WorkgroupLimits limits = getWorkgroupLimits(device);
    std::string shaderCode = readShaderFile("src/ssnp/tilt/tilt.wgsl", limits.maxWorkgroupSizeX);
    wgpu::ShaderModule shaderModule = createShaderModule(device, shaderCode);
    
    // CREATING BUFFERS FOR TILT
    wgpu::Buffer anglesBuffer = createBuffer(device, c_ba.data(), sizeof(float) * 2, wgpu::BufferUsage::Storage);
    wgpu::Buffer shapeBuffer = createBuffer(device, shape.data(), sizeof(int) * 2, wgpu::BufferUsage::Storage);
    wgpu::Buffer resBuffer = createBuffer(device, res.value().data(), sizeof(float) * 3, wgpu::BufferUsage::Storage);
    wgpu::Buffer uniformTruncBuffer = createBuffer(device, &params.trunc_flag, sizeof(uint32_t), wgpu::BufferUsage::Uniform);

    // CREATING BIND GROUP AND LAYOUT
    wgpu::BindGroupLayout bindGroupLayout = createBindGroupLayout(device);
    wgpu::BindGroup bindGroup = createBindGroup(
        device, 
        bindGroupLayout,
        anglesBuffer, 
        shapeBuffer, 
        resBuffer,
        outBuffer,  
        uniformTruncBuffer
    );

    // CREATING COMPUTE PIPELINE
    wgpu::ComputePipeline computePipeline = createComputePipeline(device, shaderModule, bindGroupLayout);

    // ENCODING AND DISPATCHING COMPUTE COMMANDS
    uint32_t workgroupsX = std::ceil(double(out_buffer_len)/limits.maxWorkgroupSizeX);
    wgpu::CommandBuffer commandBuffer = createComputeCommandBuffer(device, computePipeline, bindGroup, workgroupsX);
    queue.submit(1, &commandBuffer);
    
    // RELEASE RESOURCES
    commandBuffer.release();
    computePipeline.release();
    bindGroup.release();
    bindGroupLayout.release();
    shaderModule.release();
    anglesBuffer.release();
    shapeBuffer.release();
    resBuffer.release();
    uniformTruncBuffer.release();
}#ifndef TILT_H
#define TILT_H
#include <fstream>
#include <sstream>
#include <cassert>
#include <cmath>
#include <vector>
#include <optional>
#include <webgpu/webgpu.hpp>
#include "../webgpu_utils.h"

void tilt(
    WebGPUContext& context,
    wgpu::Buffer& outBuffer,
    std::vector<float> c_ba,
    std::vector<int> shape,
    std::optional<std::vector<float>> res = std::vector<float>{0.1, 0.1, 0.1}, 
    std::optional<bool> trunc = true
);

#endif@group(0) @binding(0) var<storage, read> c_ba : vec2<f32>;
@group(0) @binding(1) var<storage, read> shape  : array<i32>;
@group(0) @binding(2) var<storage, read> res    : array<f32>;
@group(0) @binding(3) var<storage, read_write> out : array<vec2<f32>>;
@group(0) @binding(4) var<uniform> trunc_flag : u32;

fn cmul(a: vec2<f32>, b: vec2<f32>) -> vec2<f32> {
    return vec2<f32>(a.x * b.x - a.y * b.y,
                     a.x * b.y + a.y * b.x);
}
fn cexp(theta: f32) -> vec2<f32> {
    return vec2<f32>(cos(theta), sin(theta));
}

@compute @workgroup_size({{WORKGROUP_SIZE}})
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let shape_x = u32(shape[1]);
    let shape_y = u32(shape[0]);
    let total_pixels = shape_x * shape_y;
    let total_out = total_pixels;
    if (idx >= total_out) { return; }

    // decode (angle, y, x)
    let pixel_idx = idx % total_pixels;
    let x = pixel_idx % shape_x;
    let y = pixel_idx / shape_x;

    // constants
    let pi = radians(180.0);
    let two_pi = 2.0 * pi;
    let shape_x_f = f32(shape_x);
    let shape_y_f = f32(shape_y);

    // 1) get c_ba
    let c_sin = c_ba[0];
    let c_cos = c_ba[1];

    // 2) form your “spatial frequency” and immediately normalize/divide
    //    (this keeps the numbers small), THEN optionally truncate,
    //    THEN take fract() so everything is in [0,1).
    var f_sin_norm = c_sin * res[1];
    var f_cos_norm = c_cos * res[2];
    if (trunc_flag == 1u) {
        f_sin_norm = trunc(f_sin_norm * shape_y_f) / shape_y_f;
        f_cos_norm = trunc(f_cos_norm * shape_x_f) / shape_x_f;
    }
    f_sin_norm = fract(f_sin_norm);
    f_cos_norm = fract(f_cos_norm);

    // 4) build the per‐pixel phase entirely inside [0, 2π)
    let xf = f32(x);
    let yf = f32(y);
    let phase_x = two_pi * fract(f_cos_norm * xf);
    let phase_y = two_pi * fract(f_sin_norm * yf);

    let xr = cexp(phase_x);
    let yr = cexp(phase_y);
    let val = cmul(xr, yr);

    // 5) do the same for the center‐point
    let cx = shape_x / 2u;
    let cy = shape_y / 2u;
    let cf_x = f32(cx);
    let cf_y = f32(cy);
    let center_phase_x = two_pi * fract(f_cos_norm * cf_x);
    let center_phase_y = two_pi * fract(f_sin_norm * cf_y);
    let center_x = cexp(center_phase_x);
    let center_y = cexp(center_phase_y);
    let center  = cmul(center_x, center_y);

    // apply normalization
    let inv_center = vec2<f32>(center.x, -center.y);
    out[idx] = cmul(val, inv_center);
}
#include "webgpu_utils.h"

// INITIALIZING WEBGPU
void initWebGPU(WebGPUContext& context) {
    // Create an instance
#ifdef __EMSCRIPTEN__
    context.instance = wgpuCreateInstance(nullptr);
#else
    WGPUInstanceDescriptor desc = {};
    context.instance = wgpuCreateInstance(&desc);
#endif
    if (!context.instance) {
        std::cerr << "Failed to create WebGPU instance." << std::endl;
    }

    // Request adapter
    wgpu::RequestAdapterOptions adapterOptions = {};
    adapterOptions.powerPreference = wgpu::PowerPreference::HighPerformance;
    context.adapter = context.instance.requestAdapter(adapterOptions);
    if (!context.adapter) {
        std::cerr << "Failed to request a WebGPU adapter." << std::endl;
    }

#ifdef __EMSCRIPTEN__
    // On web: default device request
    wgpu::DeviceDescriptor devDesc = {};
    context.device = context.adapter.requestDevice(devDesc);
#else
    // Native: mirror adapter limits 
    WGPUSupportedLimits supportedLimits = {};
    wgpuAdapterGetLimits(context.adapter, &supportedLimits);

    WGPURequiredLimits requiredLimits = {};
    requiredLimits.limits = supportedLimits.limits;
    requiredLimits.limits.maxBufferSize -= 1; // default bugged

    wgpu::DeviceDescriptor devDesc = {};
    devDesc.label = "Default Device";
    devDesc.requiredLimits = &requiredLimits;
    context.device = context.adapter.requestDevice(devDesc);
#endif
    if (!context.device) {
        std::cerr << "Failed to request a WebGPU device." << std::endl;
    }

    // Retrieve command queue
    context.queue = context.device.getQueue();
    if (!context.queue) {
        std::cerr << "Failed to retrieve command queue." << std::endl;
    }
}

// FETCH WORKGROUP LIMITS
WorkgroupLimits getWorkgroupLimits(wgpu::Device& device) {
    WGPUSupportedLimits limits = {};
    WorkgroupLimits result;

    bool success = wgpuDeviceGetLimits(device, &limits);
    if (success) {
        result.maxWorkgroupSizeX = double(limits.limits.maxComputeWorkgroupSizeX);
        result.maxWorkgroupSizeY = double(limits.limits.maxComputeWorkgroupSizeY);
        result.maxWorkgroupSizeZ = double(limits.limits.maxComputeWorkgroupSizeZ);
        result.maxInvocationsPerWorkgroup = double(limits.limits.maxComputeInvocationsPerWorkgroup);
    } else {
        std::cerr << "Error fetching workgroup limits." << std::endl;
        result = { -1.0, -1.0, -1.0, -1.0 }; // Return default error values
    }

    return result;
}

// LOADING AND COMPILING SHADER CODE
std::string readShaderFile(const std::string& filename, int workgroupsX, int workgroupsY, int workgroupsZ) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open shader file: " << filename << std::endl;
        return "";
    }
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string shaderCode = buffer.str();

    // Write the new workgroup sizes
    std::string workgroups = std::to_string(workgroupsX) + ", " + std::to_string(workgroupsY) + ", " + std::to_string(workgroupsZ);
    std::string token = "{{WORKGROUP_SIZE}}";
    auto pos = shaderCode.find(token);
    if (pos == std::string::npos) {
        throw std::runtime_error("WGSL template missing WORKGROUP_SIZE token");
    }
    shaderCode.replace(pos, token.size(), workgroups);

    return shaderCode;
}

wgpu::ShaderModule createShaderModule(wgpu::Device& device, const std::string& shaderCode) {
    wgpu::ShaderModuleWGSLDescriptor wgslDesc = {};
    wgslDesc.chain.next = nullptr;
    wgslDesc.chain.sType = wgpu::SType::ShaderModuleWGSLDescriptor;
    wgslDesc.code = shaderCode.c_str();

    wgpu::ShaderModuleDescriptor shaderModuleDesc = {};
    shaderModuleDesc.nextInChain = &wgslDesc.chain;

    wgpu::ShaderModule shaderModule = device.createShaderModule(shaderModuleDesc);

    if (!shaderModule) {
        std::cerr << "Failed to create shader module." << std::endl;
    }
    return shaderModule;
}

// CREATING BUFFERS
wgpu::Buffer createBuffer(wgpu::Device& device, const void* data, size_t size, wgpu::BufferUsage usage) {
    wgpu::BufferDescriptor bufferDesc = {};
    bufferDesc.size = size;
    bufferDesc.usage = usage | wgpu::BufferUsage::CopyDst;
    bufferDesc.mappedAtCreation = false;

    wgpu::Buffer buffer = device.createBuffer(bufferDesc);
    if (!buffer) {
        std::cerr << "Failed to create buffer." << std::endl;
    }

    if (data) {
        device.getQueue().writeBuffer(buffer, 0, data, size);
    }

    return buffer;
}

// COMPUTE PIPELINE UTILITIES
wgpu::ComputePipeline createComputePipeline(wgpu::Device& device, wgpu::ShaderModule shaderModule, wgpu::BindGroupLayout bindGroupLayout) {
    // Define pipeline layout
    wgpu::PipelineLayoutDescriptor pipelineLayoutDesc = {};
    pipelineLayoutDesc.bindGroupLayoutCount = 1;
    pipelineLayoutDesc.bindGroupLayouts = reinterpret_cast<WGPUBindGroupLayout*>(&bindGroupLayout);

    wgpu::PipelineLayout pipelineLayout = device.createPipelineLayout(pipelineLayoutDesc);
    if (!pipelineLayout) {
        std::cerr << "Failed to create pipeline layout." << std::endl;
        return nullptr;
    }

    // Define compute stage
    wgpu::ProgrammableStageDescriptor computeStage = {};
    computeStage.module = shaderModule;
    computeStage.entryPoint = "main";

    // Define compute pipeline
    wgpu::ComputePipelineDescriptor pipelineDesc = {};
    pipelineDesc.layout = pipelineLayout;
    pipelineDesc.compute = computeStage;

    wgpu::ComputePipeline pipeline = device.createComputePipeline(pipelineDesc);
    if (!pipeline) {
        std::cerr << "Failed to create compute pipeline." << std::endl;
    }

    return pipeline;
}

// CREATE COMMAND BUFFER
wgpu::CommandBuffer createComputeCommandBuffer(
    wgpu::Device& device,
    wgpu::ComputePipeline& computePipeline,
    wgpu::BindGroup& bindGroup,
    uint32_t workgroupsX,
    uint32_t workgroupsY,
    uint32_t workgroupsZ
) {
    wgpu::CommandEncoderDescriptor encoderDesc = {};
    wgpu::CommandEncoder commandEncoder = device.createCommandEncoder(encoderDesc);

    wgpu::ComputePassDescriptor computePassDesc = {};
    wgpu::ComputePassEncoder computePass = commandEncoder.beginComputePass(computePassDesc);
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup, 0, nullptr);
    computePass.dispatchWorkgroups(workgroupsX, workgroupsY, workgroupsZ);
    computePass.end();

    wgpu::CommandBufferDescriptor cmdBufferDesc = {};
    return commandEncoder.finish(cmdBufferDesc);
}

// READBACK RESULTS FROM GPU TO CPU
std::vector<float> readBack(wgpu::Device& device, wgpu::Queue& queue, size_t buffer_len, wgpu::Buffer& outputBuffer) {
    std::vector<float> output(buffer_len);

    wgpu::BufferDescriptor readbackBufferDesc = {};
    readbackBufferDesc.size = buffer_len * sizeof(float);
    readbackBufferDesc.usage = wgpu::BufferUsage::CopyDst | wgpu::BufferUsage::MapRead;
    wgpu::Buffer readbackBuffer = device.createBuffer(readbackBufferDesc);

    wgpu::CommandEncoderDescriptor encoderDesc = {};
    wgpu::CommandEncoder copyEncoder = device.createCommandEncoder(encoderDesc);
    copyEncoder.copyBufferToBuffer(outputBuffer, 0, readbackBuffer, 0, buffer_len * sizeof(float));

    wgpu::CommandBuffer commandBuffer = copyEncoder.finish();
    queue.submit(1, &commandBuffer);

    //MAPPING BACK TO CPU
    bool mappingComplete = false;
    auto handle = readbackBuffer.mapAsync(wgpu::MapMode::Read, 0, buffer_len * sizeof(float), [&](wgpu::BufferMapAsyncStatus status) {
        if (status == wgpu::BufferMapAsyncStatus::Success) {
            const void* mappedData = readbackBuffer.getConstMappedRange(0, buffer_len * sizeof(float));
            if (mappedData) {
                memcpy(output.data(), mappedData, buffer_len * sizeof(float));
                readbackBuffer.unmap();
            } else {
                std::cerr << "Failed to get mapped range!" << std::endl;
            }
        } else {
            std::cerr << "Failed to map buffer! Status: " << int(status) << std::endl;
        }
        mappingComplete = true;
    });

    // Wait for the mapping to complete
    while (!mappingComplete) {
    #ifndef __EMSCRIPTEN__
        wgpuDevicePoll(device, true, nullptr);
    #else
        emscripten_sleep(100); // Yield to browser event loop
    #endif
    }

    readbackBuffer.release();
    commandBuffer.release();

    return output;
}

// Temporary Fix for uint32_t types
std::vector<uint32_t> readBackInt(wgpu::Device& device, wgpu::Queue& queue, size_t buffer_len, wgpu::Buffer& outputBuffer) {
    std::vector<uint32_t> output(buffer_len);

    wgpu::BufferDescriptor readbackBufferDesc = {};
    readbackBufferDesc.size = buffer_len * sizeof(uint32_t);
    readbackBufferDesc.usage = wgpu::BufferUsage::CopyDst | wgpu::BufferUsage::MapRead;
    wgpu::Buffer readbackBuffer = device.createBuffer(readbackBufferDesc);

    wgpu::CommandEncoderDescriptor encoderDesc = {};
    wgpu::CommandEncoder copyEncoder = device.createCommandEncoder(encoderDesc);
    copyEncoder.copyBufferToBuffer(outputBuffer, 0, readbackBuffer, 0, buffer_len * sizeof(uint32_t));

    wgpu::CommandBuffer commandBuffer = copyEncoder.finish();
    queue.submit(1, &commandBuffer);

    //MAPPING BACK TO CPU
    bool mappingComplete = false;
    auto handle = readbackBuffer.mapAsync(wgpu::MapMode::Read, 0, buffer_len * sizeof(uint32_t), [&](wgpu::BufferMapAsyncStatus status) {
        if (status == wgpu::BufferMapAsyncStatus::Success) {
            const void* mappedData = readbackBuffer.getConstMappedRange(0, buffer_len * sizeof(uint32_t));
            if (mappedData) {
                memcpy(output.data(), mappedData, buffer_len * sizeof(uint32_t));
                readbackBuffer.unmap();
            } else {
                std::cerr << "Failed to get mapped range!" << std::endl;
            }
        } else {
            std::cerr << "Failed to map buffer! Status: " << int(status) << std::endl;
        }
        mappingComplete = true;
    });

    // Wait for the mapping to complete
    while (!mappingComplete) {
    #ifndef __EMSCRIPTEN__
        wgpuDevicePoll(device, true, nullptr);
    #else
        emscripten_sleep(100); // Yield to browser event loop
    #endif
    }

    readbackBuffer.release();
    commandBuffer.release();

    return output;
}#ifndef WEBGPU_UTILS_H
#define WEBGPU_UTILS_H
#include <webgpu/webgpu.hpp>
#include <fstream>
#include <sstream>
#include <vector>
#include <cstring>
#include <iostream>

struct WebGPUContext {
    wgpu::Instance instance = nullptr;
    wgpu::Adapter adapter = nullptr;
    wgpu::Device device = nullptr;
    wgpu::Queue queue = nullptr;
};

struct WorkgroupLimits {
    double maxWorkgroupSizeX;
    double maxWorkgroupSizeY;
    double maxWorkgroupSizeZ;
    double maxInvocationsPerWorkgroup;
};

// Initializes WebGPU
void initWebGPU(WebGPUContext& context);

WorkgroupLimits getWorkgroupLimits(wgpu::Device& device);

// Reads shader source code from a file
std::string readShaderFile(const std::string& filename, int workgroupsX = 256, int workgroupsY = 1, int workgroupsZ = 1);

// Creates a WebGPU shader module from WGSL source code
wgpu::ShaderModule createShaderModule(wgpu::Device& device, const std::string& shaderCode);

// Creates a WebGPU buffer
wgpu::Buffer createBuffer(wgpu::Device& device, const void* data, size_t size, wgpu::BufferUsage usage);

// Compute pipeline utilities
wgpu::ComputePipeline createComputePipeline(wgpu::Device& device, wgpu::ShaderModule shaderModule, wgpu::BindGroupLayout bindGroupLayout);

// Create command buffer
wgpu::CommandBuffer createComputeCommandBuffer(
    wgpu::Device& device,
    wgpu::ComputePipeline& computePipeline,
    wgpu::BindGroup& bindGroup,
    uint32_t workgroupsX,
    uint32_t workgroupsY = 1,
    uint32_t workgroupsZ = 1
);

// Readback from GPU to CPU
std::vector<float> readBack(wgpu::Device& device, wgpu::Queue& queue, size_t buffer_len, wgpu::Buffer& outputBuffer);
std::vector<uint32_t> readBackInt(wgpu::Device& device, wgpu::Queue& queue, size_t buffer_len, wgpu::Buffer& outputBuffer);

#endif